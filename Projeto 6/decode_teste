# Importa todas as bibliotecas necessárias
from suaBibSignal import *
import peakutils   # Biblioteca para detectar picos em dados
import numpy as np
import sounddevice as sd  # Biblioteca para capturar e manipular áudio
import matplotlib.pyplot as plt  # Biblioteca para gráficos
import time
from scipy.io.wavfile import write  # Biblioteca para manipular arquivos de áudio .wav

# Função para converter intensidade acústica em dB, caso seja necessário
def todB(s):
    sdB = 10 * np.log10(s)  # Calcula o decibel (dB) com base na intensidade acústica do sinal
    return sdB

# Dicionário de frequências DTMF para cada tecla
dtmf_frequencies = {
    '1': (679, 1209),
    '2': (679, 1336),
    '3': (679, 1477),
    '4': (770, 1209),
    '5': (770, 1336),
    '6': (770, 1477),
    '7': (825, 1209),
    '8': (825, 1336),
    '9': (825, 1477),
    '0': (941, 1336),
    '*': (941, 1209),
    '#': (941, 1477),
    'A': (679, 1633),
    'B': (770, 1633),
    'C': (825, 1633),
    'D': (941, 1633),
}

def main():
    # Cria um objeto da classe de suporte fornecida
    signal = signalMeu()  # Esse objeto possui métodos para manipulação de sinais

    # Configurações para captura de áudio com sounddevice
    sd.default.samplerate = 44100  # Taxa de amostragem de 44,1 kHz
    sd.default.channels = 1  # Número de canais de áudio (1 = mono, 2 = estéreo)
    
    tempo = 4  # Tempo de gravação em segundos
    duration = tempo  # Duração da gravação (duplicada para clareza do código)
    numAmostras = tempo * sd.default.samplerate  # Calcula o número de amostras a serem capturadas

    # Início da gravação
    print("A gravação começará em 3 segundos")
    time.sleep(3)  # Espera 3 segundos antes de iniciar a gravação
    print("Gravação iniciada")
    
    # Captura o áudio
    audio = sd.rec(int(numAmostras), sd.default.samplerate, channels=1)  # Grava o áudio do microfone
    sd.wait()  # Aguarda até que a gravação termine
    print("Gravacao finalizada")

    # Cria o vetor de tempo para o eixo x do gráfico
    T = 4  # Duração total em segundos
    t = np.linspace(0, T, T * sd.default.samplerate)  # Linspace cria pontos espaçados igualmente em um intervalo

    # Plot do áudio gravado no domínio do tempo
    plt.figure()
    plt.plot(t[:1000], audio[:1000])  # Exibe apenas os primeiros 1000 pontos para clareza
    plt.title("Áudio capturado - Domínio do Tempo")
    plt.xlabel("Tempo [s]")
    plt.ylabel("Amplitude")
    # Converter o áudio para uma única lista (necessário caso o áudio tenha mais de um canal)
    dados = audio.flatten()  # 'flatten()' transforma uma matriz multidimensional em um array unidimensional

    # Calcula a Transformada de Fourier do sinal para passar para o domínio da frequência
    xf, yf = signal.calcFFT(dados, sd.default.samplerate)  # Retorna as frequências (xf) e a amplitude (yf)

    # Definir os limites de frequência desejados
    frequencia_min = 500
    frequencia_max = 2000

    mascara = (xf >= frequencia_min) & (xf <= frequencia_max)

    # Aplicar a máscara para filtrar xf e yf
    xf_filtrado = xf[mascara]
    yf_filtrado = yf[mascara]

    # Plotar o espectro filtrado
    plt.figure()
    plt.plot(xf_filtrado, yf_filtrado)
    plt.title('Espectro de Frequência Filtrado (500 Hz - 2000 Hz)')
    plt.xlabel('Frequência [Hz]')
    plt.ylabel('Magnitude')
    plt.grid(True)

    # Detecção de picos
    indexes = peakutils.indexes(yf, thres=0.2, min_dist=40)
    peak_freqs = xf[indexes]
    peak_magnitudes = yf[indexes]

    print(f'foram detectadas {len(peak_freqs)} frequências de pico')
    print(f'as frequencias são: {peak_freqs}')
    # Listas de frequências baixas e altas DTMF
    low_freqs = [679, 770, 825, 941]
    high_freqs = [1209, 1336, 1477, 1633]

    # Variáveis para armazenar as frequências baixa e alta detectadas
    detected_low_freq = None
    detected_high_freq = None

    # Tolerância para comparação de frequências (em Hz)
    tolerance = 30

   # Separar as frequências detectadas entre baixa e alta
    for freq in peak_freqs:
        # Verifica se a frequência detectada está dentro da faixa de qualquer frequência baixa
        for low in low_freqs:
            if low - tolerance <= freq <= low + tolerance:
                print(f'Frequência baixa detectada: {low} Hz')
                detected_low_freq = low
                break
        
    # Verifica se a frequência detectada está dentro da faixa de qualquer frequência alta
    for high in high_freqs:
        if high - tolerance <= freq <= high + tolerance:
            print(f'Frequência alta detectada: {high} Hz')
            detected_high_freq = high
            break
    
    # Encontrar a tecla correspondente usando as frequências baixa e alta detectadas
    detected_key = None
    if detected_low_freq and detected_high_freq:
        for key, (f_low, f_high) in dtmf_frequencies.items():
            if f_low == detected_low_freq and f_high == detected_high_freq:
                detected_key = key
                break
        
        if detected_key:
            print(f"A tecla pressionada foi: {detected_key}")
        else:
            print("Não foi possível identificar a tecla.")

    plt.show()

if __name__ == "__main__":
    main()
