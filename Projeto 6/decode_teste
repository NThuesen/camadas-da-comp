# Importa todas as bibliotecas necessárias
from suaBibSignal import *
import peakutils   # Biblioteca para detectar picos em dados
import numpy as np
import sounddevice as sd  # Biblioteca para capturar e manipular áudio
import matplotlib.pyplot as plt  # Biblioteca para gráficos
import time
from scipy.io.wavfile import write  # Biblioteca para manipular arquivos de áudio .wav

# Função para converter intensidade acústica em dB, caso seja necessário
def todB(s):
    sdB = 10 * np.log10(s)  # Calcula o decibel (dB) com base na intensidade acústica do sinal
    return sdB

# Dicionário de frequências DTMF para cada tecla
dtmf_frequencies = {
    '1': (679, 1209),
    '2': (679, 1336),
    '3': (679, 1477),
    '4': (770, 1209),
    '5': (770, 1336),
    '6': (770, 1477),
    '7': (825, 1209),
    '8': (825, 1336),
    '9': (825, 1477),
    '0': (941, 1336),
    '*': (941, 1209),
    '#': (941, 1477),
    'A': (679, 1633),
    'B': (770, 1633),
    'C': (825, 1633),
    'D': (941, 1633),
}

def main():
    # Cria um objeto da classe de suporte fornecida
    signal = signalMeu()  # Esse objeto possui métodos para manipulação de sinais

    # Configurações para captura de áudio com sounddevice
    sd.default.samplerate = 44100  # Taxa de amostragem de 44,1 kHz
    sd.default.channels = 1  # Número de canais de áudio (1 = mono, 2 = estéreo)
    
    tempo = 4  # Tempo de gravação em segundos
    duration = tempo  # Duração da gravação (duplicada para clareza do código)
    numAmostras = tempo * sd.default.samplerate  # Calcula o número de amostras a serem capturadas

    # Início da gravação
    print("A gravação começará em 3 segundos")
    time.sleep(3)  # Espera 3 segundos antes de iniciar a gravação
    print("Gravação iniciada")
    
    # Captura o áudio
    audio = sd.rec(int(numAmostras), sd.default.samplerate, channels=1)  # Grava o áudio do microfone
    sd.wait()  # Aguarda até que a gravação termine
    print("Gravacao finalizada")

    # Cria o vetor de tempo para o eixo x do gráfico
    T = 4  # Duração total em segundos
    t = np.linspace(-T/2, T/2, T * sd.default.samplerate)  # Linspace cria pontos espaçados igualmente em um intervalo

    # Plot do áudio gravado no domínio do tempo
    plt.figure()
    plt.plot(t[:1000], audio[:1000])  # Exibe apenas os primeiros 1000 pontos para clareza
    plt.title("Áudio capturado - Domínio do Tempo")
    plt.xlabel("Tempo [s]")
    plt.ylabel("Amplitude")
    # Converter o áudio para uma única lista (necessário caso o áudio tenha mais de um canal)
    dados = audio.flatten()  # 'flatten()' transforma uma matriz multidimensional em um array unidimensional

    # Calcula a Transformada de Fourier do sinal para passar para o domínio da frequência
    xf, yf = signal.calcFFT(dados, sd.default.samplerate)  # Retorna as frequências (xf) e a amplitude (yf)

    # Plot da Transformada de Fourier do sinal
    plt.figure()
    plt.stem(xf, yf)
    plt.title("Transformada de Fourier do Sinal Gravado")
    plt.xlabel("Frequência [Hz]")
    plt.ylabel("Magnitude")
    dicio = dict(zip(xf, np.abs(yf)))

    # Ordena as frequências de pico pela magnitude em ordem decrescente
    sorted_peaks = sorted((dicio.values()), reverse=True)
    # Encontra as chaves correspondentes aos valores em sorted_peaks
    keys_sorted_peaks = []
    for peak in sorted_peaks[:300]:
        for key, value in dicio.items():
            if value == peak:
                keys_sorted_peaks.append(key)
                
    freqs_de_pico = [freq for freq in keys_sorted_peaks]
    print(f"Frequências de pico identificadas: {sorted((freqs_de_pico), reverse=True)}")
    max_picos = freqs_de_pico[:100]  # Obtém as 5 maiores frequências de pico
    #printe os picos encontrados!
    list_max_viables = []
    for valores in max_picos:
        if 500< valores < 2000:
            list_max_viables.append(valores)
            
    print(f"AAAAAAAAAAAAAAAAA de 5 picos identificados ({len(list_max_viables)} picos), ajustando parâmetros.")
    
    
    for val1, val2 in dtmf_frequencies.values():
        val1_2mais = val1 + 2
        val1_2menos = val1 - 2
        val2_2mais = val2 + 2
        val2_2menos = val2 - 2
        for valores in list_max_viables:
            if val1_2mais > valores > val1_2menos:
                freqs_de_pico.append(val1)
            if val2_2mais > valores > val2_2menos:
                freqs_de_pico.append(val2)
    
    freq = (val1, val2) 
    for key, value in dtmf_frequencies.items():
    # Ajusta os parâmetros novamente para detectar mais picos, se necessário
        if freq == value or reversed(freq) == value:
            print(f"Tecla pressionada: {key}")
            
        


    
    # Determina a tecla pressionada comparando as frequências dos picos detectados com o dicionário 'dtmf_frequencies'
    for tecla, (f1, f2) in dtmf_frequencies.items():
        if any(np.isclose(freqs_de_pico, f1, atol=5)) and any(np.isclose(freqs_de_pico, f2, atol=5)):
            # 'np.isclose' verifica se as frequências de pico estão próximas (com tolerância de 5 Hz) de f1 e f2
            print(f"A tecla pressionada foi: {tecla}")
            break
    plt.show()

if __name__ == "__main__":
    main()
